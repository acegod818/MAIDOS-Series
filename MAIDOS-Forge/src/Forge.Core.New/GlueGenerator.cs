// MAIDOS-Forge Glue Code Generator
// UEP v1.7B Compliant - Zero Technical Debt

using System.Text;

namespace Forge.Core.FFI;

/// <summary>
/// 膠水代碼生成結果
/// </summary>
/// <impl>
/// APPROACH: 封裝生成的代碼、檔案名、目標語言
/// CALLS: N/A (純資料)
/// EDGES: IsSuccess 為 false 時 Error 非空
/// </impl>
public sealed class GlueResult
{
    public bool IsSuccess { get; }
    public string Error { get; }
    public string SourceCode { get; }
    public string FileName { get; }
    public string TargetLanguage { get; }

    private GlueResult(bool isSuccess, string error, string sourceCode, string fileName, string targetLanguage)
    {
        IsSuccess = isSuccess;
        Error = error;
        SourceCode = sourceCode;
        FileName = fileName;
        TargetLanguage = targetLanguage;
    }

    public static GlueResult Success(string sourceCode, string fileName, string targetLanguage)
        => new(true, string.Empty, sourceCode, fileName, targetLanguage);

    public static GlueResult Failure(string error)
        => new(false, error, string.Empty, string.Empty, string.Empty);
}

/// <summary>
/// 膠水代碼生成器
/// </summary>
/// <impl>
/// APPROACH: 根據源接口和目標語言生成 FFI 綁定代碼
/// CALLS: GenerateCSharpGlue(), GenerateRustGlue(), GenerateCGlue()
/// EDGES: 不支援的語言組合返回失敗
/// </impl>
public static class GlueGenerator
{
    /// <summary>
    /// 生成膠水代碼
    /// </summary>
    /// <impl>
    /// APPROACH: 根據目標語言選擇對應生成器
    /// CALLS: GenerateCSharpGlue(), GenerateRustGlue(), GenerateCGlue()
    /// EDGES: 空接口返回空檔案, 不支援的語言返回失敗
    /// </impl>
    public static GlueResult Generate(ModuleInterface sourceInterface, string targetLanguage)
    {
        if (sourceInterface is null)
        {
            return GlueResult.Failure("Source interface is null");
        }

        return targetLanguage.ToLowerInvariant() switch
        {
            "csharp" or "c#" => GenerateCSharpGlue(sourceInterface),
            "rust" => GenerateRustGlue(sourceInterface),
            "c" => GenerateCGlue(sourceInterface),
            _ => GlueResult.Failure($"Unsupported target language: {targetLanguage}")
        };
    }

    /// <summary>
    /// 生成 C# P/Invoke 綁定
    /// </summary>
    /// <impl>
    /// APPROACH: 為每個導出函數生成 DllImport 聲明
    /// CALLS: GenerateCSharpParameter(), TypeRef.ToCSharpType()
    /// EDGES: unsafe 函數標記 unsafe, CLR 模式不生成 P/Invoke
    /// </impl>
    private static GlueResult GenerateCSharpGlue(ModuleInterface source)
    {
        var sb = new StringBuilder();
        var moduleName = source.ModuleName;
        var pascalName = ToPascalCase(moduleName);

        sb.AppendLine("// ═══════════════════════════════════════════════════════════════");
        sb.AppendLine($"// Auto-generated by MAIDOS-Forge FFI Engine");
        sb.AppendLine($"// Source: {moduleName} ({source.Language})");
        sb.AppendLine($"// Generated: {DateTime.UtcNow:yyyy-MM-ddTHH:mm:ssZ}");
        sb.AppendLine("// DO NOT EDIT - Changes will be overwritten");
        sb.AppendLine("// ═══════════════════════════════════════════════════════════════");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Runtime.InteropServices;");
        sb.AppendLine();
        sb.AppendLine($"namespace {pascalName}.Interop;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// P/Invoke bindings for {moduleName} module");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"internal static unsafe partial class {pascalName}Native");
        sb.AppendLine("{");
        sb.AppendLine($"    private const string LibraryName = \"{moduleName}\";");
        sb.AppendLine();

        foreach (var export in source.Exports)
        {
            GenerateCSharpFunction(sb, export);
            sb.AppendLine();
        }

        sb.AppendLine("}");

        var fileName = $"{pascalName}.Interop.cs";
        return GlueResult.Success(sb.ToString(), fileName, "csharp");
    }

    /// <summary>
    /// 生成單一 C# P/Invoke 函數
    /// </summary>
    /// <impl>
    /// APPROACH: 生成 DllImport 屬性和方法簽名
    /// CALLS: GetCallingConvention(), TypeRef.ToCSharpType()
    /// EDGES: 函數指標參數需要 unsafe
    /// </impl>
    private static void GenerateCSharpFunction(StringBuilder sb, ExportedFunction export)
    {
        var sig = export.Signature;
        var convention = GetCSharpCallingConvention(sig.Convention);
        var returnType = sig.ReturnType.ToCSharpType();
        var isUnsafe = export.Attributes.Contains("unsafe") ||
                       sig.Parameters.Any(p => p.Type is PointerType or FunctionPointerType) ||
                       sig.ReturnType is PointerType or FunctionPointerType;

        // 文檔註釋
        sb.AppendLine($"    /// <summary>{export.Name}</summary>");
        if (export.Attributes.Count > 0)
        {
            sb.AppendLine($"    /// <remarks>Attributes: {string.Join(", ", export.Attributes)}</remarks>");
        }

        // DllImport 屬性
        sb.AppendLine($"    [DllImport(LibraryName, CallingConvention = CallingConvention.{convention}, EntryPoint = \"{export.Name}\")]");

        // 方法簽名
        var unsafeKeyword = isUnsafe ? "unsafe " : "";
        var parameters = string.Join(", ", sig.Parameters.Select(GenerateCSharpParameter));

        sb.AppendLine($"    public static extern {unsafeKeyword}{returnType} {export.Name}({parameters});");
    }

    /// <summary>
    /// 生成 C# 參數
    /// </summary>
    /// <impl>
    /// APPROACH: 根據參數方向添加 out/ref 修飾符
    /// CALLS: TypeRef.ToCSharpType()
    /// EDGES: Out 參數加 out, InOut 加 ref
    /// </impl>
    private static string GenerateCSharpParameter(FunctionParameter param)
    {
        var type = param.Type.ToCSharpType();
        var direction = param.Direction switch
        {
            ParameterDirection.Out => "out ",
            ParameterDirection.InOut => "ref ",
            _ => ""
        };

        // 避免 C# 關鍵字衝突
        var name = param.Name switch
        {
            "out" => "@out",
            "ref" => "@ref",
            "in" => "@in",
            "params" => "@params",
            "event" => "@event",
            _ => param.Name
        };

        return $"{direction}{type} {name}";
    }

    /// <summary>
    /// 生成 Rust FFI 綁定
    /// </summary>
    /// <impl>
    /// APPROACH: 為每個導出函數生成 extern "C" 聲明
    /// CALLS: GenerateRustParameter(), TypeRef.ToRustType()
    /// EDGES: 指標參數需要 unsafe 區塊
    /// </impl>
    private static GlueResult GenerateRustGlue(ModuleInterface source)
    {
        var sb = new StringBuilder();
        var moduleName = source.ModuleName;
        var snakeName = ToSnakeCase(moduleName);

        sb.AppendLine("// ═══════════════════════════════════════════════════════════════");
        sb.AppendLine($"// Auto-generated by MAIDOS-Forge FFI Engine");
        sb.AppendLine($"// Source: {moduleName} ({source.Language})");
        sb.AppendLine($"// Generated: {DateTime.UtcNow:yyyy-MM-ddTHH:mm:ssZ}");
        sb.AppendLine("// DO NOT EDIT - Changes will be overwritten");
        sb.AppendLine("// ═══════════════════════════════════════════════════════════════");
        sb.AppendLine();
        sb.AppendLine("#![allow(non_snake_case)]");
        sb.AppendLine("#![allow(non_camel_case_types)]");
        sb.AppendLine();

        // 連結指令
        sb.AppendLine($"#[link(name = \"{moduleName}\")]");
        sb.AppendLine("extern \"C\" {");

        foreach (var export in source.Exports)
        {
            GenerateRustFunction(sb, export);
        }

        sb.AppendLine("}");
        sb.AppendLine();

        // 生成安全包裝器
        sb.AppendLine($"/// Safe wrapper module for {moduleName}");
        sb.AppendLine($"pub mod {snakeName} {{");
        sb.AppendLine("    use super::*;");
        sb.AppendLine();

        foreach (var export in source.Exports)
        {
            GenerateRustSafeWrapper(sb, export);
        }

        sb.AppendLine("}");

        var fileName = $"{snakeName}_ffi.rs";
        return GlueResult.Success(sb.ToString(), fileName, "rust");
    }

    /// <summary>
    /// 生成單一 Rust extern 函數
    /// </summary>
    /// <impl>
    /// APPROACH: 生成 extern "C" 函數聲明
    /// CALLS: TypeRef.ToRustType()
    /// EDGES: N/A
    /// </impl>
    private static void GenerateRustFunction(StringBuilder sb, ExportedFunction export)
    {
        var sig = export.Signature;
        var returnType = sig.ReturnType.ToRustType();
        var parameters = string.Join(", ", sig.Parameters.Select(p =>
            $"{ToSnakeCase(p.Name)}: {p.Type.ToRustType()}"));

        sb.AppendLine($"    /// {export.Name}");
        if (returnType == "()")
        {
            sb.AppendLine($"    pub fn {export.Name}({parameters});");
        }
        else
        {
            sb.AppendLine($"    pub fn {export.Name}({parameters}) -> {returnType};");
        }
    }

    /// <summary>
    /// 生成 Rust 安全包裝器
    /// </summary>
    /// <impl>
    /// APPROACH: 將 unsafe extern 函數包裝為安全 Rust 函數
    /// CALLS: TypeRef.ToRustType()
    /// EDGES: 所有 FFI 調用都是 unsafe
    /// </impl>
    private static void GenerateRustSafeWrapper(StringBuilder sb, ExportedFunction export)
    {
        var sig = export.Signature;
        var funcName = ToSnakeCase(export.Name);
        var returnType = sig.ReturnType.ToRustType();

        // 簡化的安全包裝器
        var parameters = string.Join(", ", sig.Parameters.Select(p =>
            $"{ToSnakeCase(p.Name)}: {p.Type.ToRustType()}"));
        var args = string.Join(", ", sig.Parameters.Select(p => ToSnakeCase(p.Name)));

        sb.AppendLine($"    /// Safe wrapper for {export.Name}");
        sb.AppendLine("    #[inline]");

        if (returnType == "()")
        {
            sb.AppendLine($"    pub unsafe fn {funcName}({parameters}) {{");
            sb.AppendLine($"        super::{export.Name}({args})");
        }
        else
        {
            sb.AppendLine($"    pub unsafe fn {funcName}({parameters}) -> {returnType} {{");
            sb.AppendLine($"        super::{export.Name}({args})");
        }

        sb.AppendLine("    }");
        sb.AppendLine();
    }

    /// <summary>
    /// 生成 C 頭檔
    /// </summary>
    /// <impl>
    /// APPROACH: 生成標準 C 頭檔格式
    /// CALLS: GenerateCFunction(), TypeRef.ToCType()
    /// EDGES: 包含 include guard
    /// </impl>
    private static GlueResult GenerateCGlue(ModuleInterface source)
    {
        var sb = new StringBuilder();
        var moduleName = source.ModuleName;
        var upperName = moduleName.ToUpperInvariant().Replace('-', '_');
        var guard = $"{upperName}_FFI_H";

        sb.AppendLine("/*");
        sb.AppendLine(" * ═══════════════════════════════════════════════════════════════");
        sb.AppendLine($" * Auto-generated by MAIDOS-Forge FFI Engine");
        sb.AppendLine($" * Source: {moduleName} ({source.Language})");
        sb.AppendLine($" * Generated: {DateTime.UtcNow:yyyy-MM-ddTHH:mm:ssZ}");
        sb.AppendLine(" * DO NOT EDIT - Changes will be overwritten");
        sb.AppendLine(" * ═══════════════════════════════════════════════════════════════");
        sb.AppendLine(" */");
        sb.AppendLine();
        sb.AppendLine($"#ifndef {guard}");
        sb.AppendLine($"#define {guard}");
        sb.AppendLine();
        sb.AppendLine("#include <stdint.h>");
        sb.AppendLine("#include <stdbool.h>");
        sb.AppendLine("#include <stddef.h>");
        sb.AppendLine();
        sb.AppendLine("#ifdef __cplusplus");
        sb.AppendLine("extern \"C\" {");
        sb.AppendLine("#endif");
        sb.AppendLine();

        // 前向聲明
        var structTypes = source.Exports
            .SelectMany(e => GetStructTypes(e.Signature))
            .Distinct()
            .ToList();

        if (structTypes.Count > 0)
        {
            sb.AppendLine("/* Forward declarations */");
            foreach (var structName in structTypes)
            {
                sb.AppendLine($"struct {structName};");
            }
            sb.AppendLine();
        }

        // 函數聲明
        sb.AppendLine("/* Function declarations */");
        foreach (var export in source.Exports)
        {
            GenerateCFunction(sb, export);
        }

        sb.AppendLine();
        sb.AppendLine("#ifdef __cplusplus");
        sb.AppendLine("}");
        sb.AppendLine("#endif");
        sb.AppendLine();
        sb.AppendLine($"#endif /* {guard} */");

        var fileName = $"{moduleName}_ffi.h";
        return GlueResult.Success(sb.ToString(), fileName, "c");
    }

    /// <summary>
    /// 生成單一 C 函數聲明
    /// </summary>
    /// <impl>
    /// APPROACH: 生成 C 函數原型
    /// CALLS: TypeRef.ToCType()
    /// EDGES: 空參數列表使用 void
    /// </impl>
    private static void GenerateCFunction(StringBuilder sb, ExportedFunction export)
    {
        var sig = export.Signature;
        var returnType = sig.ReturnType.ToCType();

        var parameters = sig.Parameters.Count > 0
            ? string.Join(", ", sig.Parameters.Select(p => $"{p.Type.ToCType()} {p.Name}"))
            : "void";

        // 屬性註釋
        if (export.Attributes.Count > 0)
        {
            sb.AppendLine($"/* Attributes: {string.Join(", ", export.Attributes)} */");
        }

        sb.AppendLine($"{returnType} {export.Name}({parameters});");
        sb.AppendLine();
    }

    /// <summary>
    /// 取得簽名中的所有結構類型名稱
    /// </summary>
    /// <impl>
    /// APPROACH: 遞迴遍歷所有類型
    /// CALLS: 自身遞迴
    /// EDGES: N/A
    /// </impl>
    private static IEnumerable<string> GetStructTypes(FunctionSignature sig)
    {
        foreach (var param in sig.Parameters)
        {
            foreach (var name in GetStructTypesFromType(param.Type))
            {
                yield return name;
            }
        }

        foreach (var name in GetStructTypesFromType(sig.ReturnType))
        {
            yield return name;
        }
    }

    private static IEnumerable<string> GetStructTypesFromType(TypeRef type)
    {
        return type switch
        {
            StructType s => new[] { s.Name },
            PointerType p => GetStructTypesFromType(p.Pointee),
            ArrayType a => GetStructTypesFromType(a.Element),
            FunctionPointerType f => GetStructTypes(f.Signature),
            _ => Enumerable.Empty<string>()
        };
    }

    private static string GetCSharpCallingConvention(CallingConvention conv) => conv switch
    {
        CallingConvention.Stdcall => "StdCall",
        CallingConvention.Fastcall => "FastCall",
        CallingConvention.Thiscall => "ThisCall",
        _ => "Cdecl"
    };

    private static string ToPascalCase(string s)
    {
        if (string.IsNullOrEmpty(s)) return s;
        var parts = s.Split('-', '_');
        return string.Concat(parts.Select(p =>
            char.ToUpperInvariant(p[0]) + p.Substring(1).ToLowerInvariant()));
    }

    private static string ToSnakeCase(string s)
    {
        if (string.IsNullOrEmpty(s)) return s;

        var sb = new StringBuilder();
        for (int i = 0; i < s.Length; i++)
        {
            var c = s[i];
            if (char.IsUpper(c))
            {
                if (i > 0) sb.Append('_');
                sb.Append(char.ToLowerInvariant(c));
            }
            else if (c == '-')
            {
                sb.Append('_');
            }
            else
            {
                sb.Append(c);
            }
        }
        return sb.ToString();
    }
}

#!/usr/bin/env python3
"""Batch translate Chinese comments to English in all .cs files."""
import os, re, glob

DIR = os.path.dirname(os.path.abspath(__file__))

# Translation dictionary: Chinese -> English
T = {
    # ProcessRunner.cs
    "進程執行結果": "Process execution result",
    "進程執行配置": "Process execution configuration",
    "外部進程執行器": "External process runner",
    "超時處理": "Timeout handling",
    "用戶取消處理": "User cancellation handling",

    # ConfigParser.cs
    "配置解析結果": "Configuration parse result",
    "Result 模式封裝成功/失敗，避免異常作為控制流": "Result pattern encapsulating success/failure, avoiding exceptions as control flow",
    "N/A (純資料)": "N/A (pure data)",
    "純資料": "pure data",
    "IsSuccess 與 Error 互斥，Value 僅在成功時有效": "IsSuccess and Error are mutually exclusive, Value is only valid on success",
    "已驗證的專案配置（不可變）": "Validated project configuration (immutable)",
    "將解析後的配置封裝為不可變結構，包含專案根目錄": "Encapsulates parsed config as immutable structure, including project root",
    "所有欄位在建構時驗證完成": "All fields are validated at construction time",
    "已驗證的模組配置（不可變）": "Validated module configuration (immutable)",
    "將解析後的模組配置封裝為不可變結構": "Encapsulates parsed module config as immutable structure",
    "ModulePath 為絕對路徑": "ModulePath is an absolute path",
    "配置解析器 - 負責讀取與驗證 forge.json 和 module.json": "Configuration parser - reads and validates forge.json and module.json",
    "靜態方法組，從檔案系統讀取 JSON 並反序列化，驗證必填欄位": "Static method group, reads JSON from file system, deserializes and validates required fields",
    "File.ReadAllText(), JsonSerializer.Deserialize()": "File.ReadAllText(), JsonSerializer.Deserialize()",
    "檔案不存在返回失敗, JSON 語法錯誤返回失敗, 必填欄位空返回失敗": "File not found returns failure, JSON syntax error returns failure, empty required field returns failure",
    "解析專案配置": "Parse project configuration",
    "讀取 forge.json，驗證必填欄位，遞迴解析所有模組": "Read forge.json, validate required fields, recursively parse all modules",
    "File.ReadAllText(), JsonSerializer.Deserialize(), ParseModuleConfig()": "File.ReadAllText(), JsonSerializer.Deserialize(), ParseModuleConfig()",
    "專案目錄不存在返回失敗, forge.json 不存在返回失敗, name 空返回失敗": "Project directory not found returns failure, forge.json not found returns failure, empty name returns failure",
    "驗證專案目錄存在": "Verify project directory exists",
    "驗證 forge.json 存在": "Verify forge.json exists",
    "讀取並解析 forge.json": "Read and parse forge.json",
    "驗證必填欄位": "Validate required fields",
    "解析所有模組": "Parse all modules",
    "使用顯式列出的模組": "Use explicitly listed modules",
    "自動發現 modules/ 下的所有子目錄": "Auto-discover all subdirectories under modules/",
    "解析單一模組配置": "Parse single module configuration",
    "讀取 module.json，驗證必填欄位": "Read module.json, validate required fields",
    "目錄不存在返回失敗, module.json 不存在返回失敗, name/language 空返回失敗": "Directory not found returns failure, module.json not found returns failure, empty name/language returns failure",
    "驗證模組目錄存在": "Verify module directory exists",
    "驗證 module.json 存在": "Verify module.json exists",
    "讀取並解析 module.json": "Read and parse module.json",
    "驗證語言是支援的": "Validate language is supported",

    # Models.cs
    "專案配置 (forge.json)": "Project configuration (forge.json)",
    "這個類別代表整個專案的配置，對應於專案根目錄下的 forge.json 檔案。": "This class represents the entire project configuration, corresponding to the forge.json file in the project root.",
    "它包含了專案的基本資訊、輸出設定、目標平台以及模組列表。": "It contains the project's basic information, output settings, target platform, and module list.",
    "APPROACH: POCO 模型，映射 forge.json 根結構": "APPROACH: POCO model, maps to forge.json root structure",
    "CALLS: System.Text.Json 反序列化": "CALLS: System.Text.Json deserialization",
    "EDGES: 所有欄位可空並有預設值，允許漸進式配置": "EDGES: All fields are nullable with defaults, allowing incremental configuration",
    "輸出配置": "Output configuration",
    "定義編譯輸出的目錄結構和產物名稱。": "Defines the output directory structure and artifact names for compilation.",
    "APPROACH: 定義 build 輸出目錄結構": "APPROACH: Defines build output directory structure",
    "EDGES: 預設值確保最小可用配置": "EDGES: Default values ensure a minimal working configuration",
    "目標平台配置": "Target platform configuration",
    "定義編譯的目標平台，包括默認平台和交叉編譯選項。": "Defines the compilation target platform, including default platform and cross-compilation options.",
    "APPROACH: 定義編譯目標平台與交叉編譯選項": "APPROACH: Defines compilation target platform and cross-compilation options",
    "EDGES: 預設當前平台，sysroot 為 auto": "EDGES: Defaults to current platform, sysroot is auto",
    "交叉編譯配置": "Cross-compilation configuration",
    "定義交叉編譯時使用的 sysroot 來源。": "Defines the sysroot source used during cross-compilation.",
    "APPROACH: 定義 sysroot 來源": "APPROACH: Defines sysroot source",
    "EDGES: auto = 自動下載, generate = 本地生成, 或自訂路徑": "EDGES: auto = auto-download, generate = local generation, or custom path",
    "模組配置 (module.json)": "Module configuration (module.json)",
    "這個類別代表單一模組的配置，對應於模組目錄下的 module.json 檔案。": "This class represents a single module configuration, corresponding to the module.json file in the module directory.",
    "它包含了模組的基本資訊、語言設定、依賴關係以及語言特定的配置。": "It contains the module's basic information, language settings, dependencies, and language-specific configuration.",
    "APPROACH: POCO 模型，映射 module.json 根結構": "APPROACH: POCO model, maps to module.json root structure",
    "EDGES: language 必填（無預設），其他欄位有預設值": "EDGES: language is required (no default), other fields have defaults",
    "導出接口配置": "Export interface configuration",
    "定義模組對外暴露的函數接口，包括函數名稱和調用約定。": "Defines the function interfaces exposed by the module, including function names and calling conventions.",
    "APPROACH: 定義模組對外暴露的符號": "APPROACH: Defines symbols exposed by the module",
    "EDGES: name 必填，calling_convention 預設 cdecl": "EDGES: name is required, calling_convention defaults to cdecl",
    "C# 語言特定配置": "C# language-specific configuration",
    "APPROACH: 定義 C# 編譯選項（CLR vs NativeAOT）": "APPROACH: Defines C# compilation options (CLR vs NativeAOT)",
    "EDGES: mode 預設 clr，framework 預設 net8.0": "EDGES: mode defaults to clr, framework defaults to net8.0",
    "Rust 語言特定配置": "Rust language-specific configuration",
    "APPROACH: 定義 Rust 編譯選項": "APPROACH: Defines Rust compilation options",
    "EDGES: edition 預設 2021，profile 預設 release": "EDGES: edition defaults to 2021, profile defaults to release",
    "C 語言特定配置": "C language-specific configuration",
    "APPROACH: 定義 C 編譯選項": "APPROACH: Defines C compilation options",
    "EDGES: compiler 預設空（自動偵測），standard 預設 c17": "EDGES: compiler defaults to empty (auto-detect), standard defaults to c17",
    "C++ 語言特定配置": "C++ language-specific configuration",
    "APPROACH: 定義 C++ 編譯選項": "APPROACH: Defines C++ compilation options",
    "EDGES: compiler 預設空（自動偵測），standard 預設 c++17": "EDGES: compiler defaults to empty (auto-detect), standard defaults to c++17",
    "Go 語言特定配置": "Go language-specific configuration",
    "APPROACH: 定義 Go 編譯選項": "APPROACH: Defines Go compilation options",
    "EDGES: buildmode 預設 c-shared 以支援 FFI": "EDGES: buildmode defaults to c-shared for FFI support",
    "TypeScript 語言特定配置": "TypeScript language-specific configuration",
    "APPROACH: 定義 TypeScript 編譯選項": "APPROACH: Defines TypeScript compilation options",
    "EDGES: bundler 預設 esbuild，target 預設 es2020": "EDGES: bundler defaults to esbuild, target defaults to es2020",
    "Python 語言特定配置": "Python language-specific configuration",
    "APPROACH: 定義 Python 編譯選項（Cython/mypyc/Nuitka）": "APPROACH: Defines Python compilation options (Cython/mypyc/Nuitka)",
    "EDGES: compiler 預設 cython": "EDGES: compiler defaults to cython",
    "Assembly 語言特定配置": "Assembly language-specific configuration",
    "APPROACH: 定義 Assembly 編譯選項（NASM/GAS/MASM）": "APPROACH: Defines Assembly compilation options (NASM/GAS/MASM)",
    "EDGES: assembler 預設空（自動偵測），format 依平台決定": "EDGES: assembler defaults to empty (auto-detect), format determined by platform",

    # ForgeNative.cs
    "對齊 Rust maidos-forge-core/src/ffi.rs 的 10 個 FFI 導出函數": "Aligned with 10 FFI export functions from Rust maidos-forge-core/src/ffi.rs",
    "參照 SharedCore P/Invoke 模式": "Following SharedCore P/Invoke pattern",
    "[MAIDOS-AUDIT] 10 個 DllImport 聲明對齊 Rust FFI 導出": "[MAIDOS-AUDIT] 10 DllImport declarations aligned with Rust FFI exports",
    "Rust maidos_forge_core.dll 的 P/Invoke 綁定": "P/Invoke bindings for Rust maidos_forge_core.dll",
    "核心功能 FFI (6 個)": "Core FFI functions (6)",
    "解析源碼文件，返回 JSON 格式的 AST": "Parse source file, return AST in JSON format",
    "語言名稱 (\"rust\", \"c\", \"cpp\")": "Language name (\"rust\", \"c\", \"cpp\")",
    "源碼文件路徑": "Source file path",
    "JSON 字串指標，需用 forge_free_string 釋放；失敗返回 IntPtr.Zero": "JSON string pointer, must be freed with forge_free_string; returns IntPtr.Zero on failure",
    "檢查源碼語法，返回 JSON 格式的診斷結果": "Check source syntax, return diagnostic results in JSON format",
    "返回支援的解析語言列表 (JSON 陣列)": "Return list of supported parsing languages (JSON array)",
    "返回 Forge Core 版本資訊 (JSON)": "Return Forge Core version info (JSON)",
    "批次解析多個源碼文件": "Batch parse multiple source files",
    "語言名稱": "Language name",
    "JSON 陣列格式的路徑列表": "Path list in JSON array format",
    "增量解析源碼文件": "Incremental parse source file",
    "前次的 file_hash (可為 IntPtr.Zero)": "Previous file_hash (can be IntPtr.Zero)",
    "記憶體管理 FFI (4 個)": "Memory management FFI (4)",
    "獲取最後一次錯誤信息": "Get last error message",
    "釋放 FFI 返回的字串": "Free string returned by FFI",
    "初始化 Forge Core": "Initialize Forge Core",
    "清除最後一次錯誤": "Clear last error",
    "高階 Managed 包裝 — 封裝 ForgeNative 的指標操作": "High-level managed wrapper - encapsulates ForgeNative pointer operations",
    "提供 C# 友善的 API": "Provides C#-friendly API",
    "初始化 Forge Core 引擎": "Initialize Forge Core engine",
    "解析源碼文件並返回 JSON AST": "Parse source file and return JSON AST",
    "源碼文件的完整路徑": "Full path to the source file",
    "JSON 字串，失敗時拋出異常": "JSON string, throws exception on failure",
    "檢查源碼語法並返回 JSON 診斷結果": "Check source syntax and return JSON diagnostic results",
    "獲取支援的語言列表": "Get supported language list",
    "獲取 Forge Core 版本資訊": "Get Forge Core version info",
    "批次解析多個源碼文件": "Batch parse multiple source files",
    "增量解析源碼文件": "Incremental parse source file",
    "從 Rust FFI 返回的指標讀取字串並釋放記憶體": "Read string from Rust FFI returned pointer and free memory",
    "獲取最後一次 Rust 端錯誤信息": "Get last error message from Rust side",

    # Common patterns across many files
    "取得插件能力": "Get plugin capabilities",
    "返回預定義的能力描述": "Return predefined capability description",
    "編譯": "Compile",
    "驗證工具鏈": "Validate toolchain",
    "提取接口": "Extract interface",
    "生成膠水代碼": "Generate glue code",
    "生成 C# P/Invoke 膠水": "Generate C# P/Invoke glue",
    "生成 Rust FFI 膠水": "Generate Rust FFI glue",
    "生成 C 頭檔": "Generate C header file",
    "不支援的目標語言返回 Failure": "Unsupported target language returns Failure",
    "空導出返回空檔案": "Empty exports return empty file",

    # CSharpPlugin.cs
    "C# 語言插件 - 支援 CLR 和 NativeAOT 模式": "C# language plugin - supports CLR and NativeAOT modes",
    "封裝 dotnet build 命令，支援兩種編譯模式": "Wraps dotnet build command, supports two compilation modes",
    "ProcessRunner.RunAsync(), dotnet CLI": "ProcessRunner.RunAsync(), dotnet CLI",
    "無 dotnet CLI 時 ValidateToolchain 返回失敗": "ValidateToolchain returns failure when dotnet CLI is unavailable",
    "編譯 C# 模組": "Compile C# module",
    "根據 mode 選擇 CLR 或 NativeAOT 編譯路徑": "Select CLR or NativeAOT compilation path based on mode",
    "CompileClrAsync(), CompileNativeAotAsync()": "CompileClrAsync(), CompileNativeAotAsync()",
    "無 .csproj 時嘗試建立臨時專案, 無源碼時返回失敗": "Attempt to create temporary project when no .csproj, return failure when no source code",
    "確定編譯模式": "Determine compilation mode",
    "查找 .csproj": "Find .csproj",
    "沒有 .csproj，建立臨時專案": "No .csproj, creating temporary project",
    "執行編譯": "Execute compilation",
    "CLR 模式編譯": "CLR mode compilation",
    "執行 dotnet build，輸出 .dll": "Execute dotnet build, output .dll",
    "編譯失敗返回 Failure 並附帶錯誤日誌": "Compilation failure returns Failure with error logs",
    "收集產物": "Collect artifacts",
    "NativeAOT 模式編譯": "NativeAOT mode compilation",
    "執行 dotnet publish -p:PublishAot=true，輸出原生二進制": "Execute dotnet publish -p:PublishAot=true, output native binary",
    "需要 NativeAOT 工具鏈，失敗返回詳細錯誤": "Requires NativeAOT toolchain, failure returns detailed error",
    "確定 RID": "Determine RID",
    "NativeAOT 需要更長時間": "NativeAOT requires more time",
    "收集產物 (原生二進制)": "Collect artifacts (native binaries)",
    "原生執行檔或共享庫": "Native executable or shared library",
    "建立臨時 .csproj": "Create temporary .csproj",
    "根據模組配置生成 .csproj XML": "Generate .csproj XML based on module configuration",
    "File.WriteAllText()": "File.WriteAllText()",
    "目錄不存在時建立, 無 .cs 檔案返回失敗": "Create directory if it doesn't exist, return failure when no .cs files",
    "檢查是否有 .cs 檔案": "Check for .cs files",
    "從編譯產物提取接口": "Extract interface from compiled artifacts",
    "使用反射載入 DLL 並列舉公開方法（CLR 模式）": "Use reflection to load DLL and enumerate public methods (CLR mode)",
    "Assembly.LoadFrom(), Type.GetMethods()": "Assembly.LoadFrom(), Type.GetMethods()",
    "非 .dll 返回 null, 載入失敗返回 null": "Non-.dll returns null, load failure returns null",
    "生成跨語言膠水代碼": "Generate cross-language glue code",
    "根據目標語言生成 P/Invoke 或 extern 聲明": "Generate P/Invoke or extern declarations based on target language",
    "GenerateRustGlue(), GenerateCGlue()": "GenerateRustGlue(), GenerateCGlue()",
    "為每個導出函數生成 extern \"C\" 聲明": "Generate extern \"C\" declaration for each exported function",
    "為每個導出函數生成 C 函數聲明": "Generate C function declaration for each exported function",
    "驗證 dotnet CLI 是否可用": "Validate whether dotnet CLI is available",
    "執行 dotnet --version": "Execute dotnet --version",
    "ProcessRunner.GetVersionAsync()": "ProcessRunner.GetVersionAsync()",
    "不可用返回失敗訊息": "Returns failure message when unavailable",
    "取得當前平台 RID": "Get current platform RID",
    "根據 OS 和架構組合 RID": "Combine OS and architecture into RID",
    "OperatingSystem, RuntimeInformation": "OperatingSystem, RuntimeInformation",
    "未知平台返回 linux-x64 作為預設": "Unknown platform returns linux-x64 as default",

    # RustPlugin.cs
    "Rust 語言插件 - 封裝 cargo build": "Rust language plugin - wraps cargo build",
    "封裝 cargo 命令，支援原生編譯和交叉編譯": "Wraps cargo command, supports native and cross-compilation",
    "ProcessRunner.RunAsync(), cargo CLI": "ProcessRunner.RunAsync(), cargo CLI",
    "無 cargo 時 ValidateToolchain 返回失敗": "ValidateToolchain returns failure when cargo is unavailable",
    "編譯 Rust 模組": "Compile Rust module",
    "優先使用 Cargo.toml，否則直接 rustc 編譯": "Prefer Cargo.toml, otherwise compile directly with rustc",
    "CompileWithCargoAsync(), CompileWithRustcAsync()": "CompileWithCargoAsync(), CompileWithRustcAsync()",
    "無 Cargo.toml 且無 .rs 檔案返回失敗": "Return failure when no Cargo.toml and no .rs files",
    "查找 Cargo.toml": "Find Cargo.toml",
    "查找 .rs 檔案": "Find .rs files",
    "使用 Cargo 編譯": "Compile with Cargo",
    "執行 cargo build --release，輸出 .rlib 或原生庫": "Execute cargo build --release, output .rlib or native library",
    "交叉編譯目標": "Cross-compilation target",
    "查找庫檔案": "Find library files",
    "複製到輸出目錄": "Copy to output directory",
    "直接使用 rustc 編譯": "Compile directly with rustc",
    "對每個 .rs 檔案執行 rustc，輸出 .rlib": "Execute rustc for each .rs file, output .rlib",
    "僅適用於簡單單檔案模組": "Only suitable for simple single-file modules",
    "查找 lib.rs 或使用第一個檔案": "Find lib.rs or use the first file",
    "交叉編譯": "Cross-compilation",
    "從編譯產物提取接口": "Extract interface from compiled artifacts",
    "使用 nm 或 rustfilt 解析符號表": "Parse symbol table using nm or rustfilt",
    "ProcessRunner.RunAsync(), nm": "ProcessRunner.RunAsync(), nm",
    "非庫檔案返回 null, 解析失敗返回空接口": "Non-library file returns null, parse failure returns empty interface",
    "使用 nm 列出符號": "List symbols using nm",
    "簡化解析：尋找 T 類型的符號（text section, global）": "Simplified parsing: find T-type symbols (text section, global)",
    "過濾掉 Rust mangled 符號，只保留 extern \"C\" 函數": "Filter out Rust mangled symbols, keep only extern \"C\" functions",
    "根據目標語言生成 extern 或 P/Invoke 聲明": "Generate extern or P/Invoke declarations based on target language",
    "GenerateCSharpGlue(), GenerateCGlue()": "GenerateCSharpGlue(), GenerateCGlue()",
    "為每個導出函數生成 DllImport 聲明": "Generate DllImport declaration for each exported function",
    "驗證 Rust 工具鏈是否可用": "Validate whether Rust toolchain is available",
    "執行 rustc --version 和 cargo --version": "Execute rustc --version and cargo --version",
    "任一不可用返回失敗訊息": "Returns failure message when either is unavailable",
    "映射 Forge target 到 Rust target triple": "Map Forge target to Rust target triple",
    "字典查找": "Dictionary lookup",
    "未知目標返回 null": "Unknown target returns null",

    # GlueGenerator.cs
    "膠水代碼生成結果": "Glue code generation result",
    "封裝生成的代碼、檔案名、目標語言": "Encapsulates generated code, filename, and target language",
    "IsSuccess 為 false 時 Error 非空": "Error is non-empty when IsSuccess is false",
    "膠水代碼生成器": "Glue code generator",
    "根據源接口和目標語言生成 FFI 綁定代碼": "Generate FFI binding code based on source interface and target language",
    "GenerateCSharpGlue(), GenerateRustGlue(), GenerateCGlue()": "GenerateCSharpGlue(), GenerateRustGlue(), GenerateCGlue()",
    "不支援的語言組合返回失敗": "Unsupported language combination returns failure",
    "生成膠水代碼": "Generate glue code",
    "根據目標語言選擇對應生成器": "Select corresponding generator based on target language",
    "空接口返回空檔案, 不支援的語言返回失敗": "Empty interface returns empty file, unsupported language returns failure",
    "生成 C# P/Invoke 綁定": "Generate C# P/Invoke bindings",
    "GenerateCSharpParameter(), TypeRef.ToCSharpType()": "GenerateCSharpParameter(), TypeRef.ToCSharpType()",
    "unsafe 函數標記 unsafe, CLR 模式不生成 P/Invoke": "unsafe functions are marked unsafe, CLR mode does not generate P/Invoke",
    "生成單一 C# P/Invoke 函數": "Generate single C# P/Invoke function",
    "生成 DllImport 屬性和方法簽名": "Generate DllImport attribute and method signature",
    "GetCallingConvention(), TypeRef.ToCSharpType()": "GetCallingConvention(), TypeRef.ToCSharpType()",
    "函數指標參數需要 unsafe": "Function pointer parameters require unsafe",
    "文檔註釋": "Documentation comment",
    "DllImport 屬性": "DllImport attribute",
    "方法簽名": "Method signature",
    "生成 C# 參數": "Generate C# parameter",
    "根據參數方向添加 out/ref 修飾符": "Add out/ref modifiers based on parameter direction",
    "TypeRef.ToCSharpType()": "TypeRef.ToCSharpType()",
    "Out 參數加 out, InOut 加 ref": "Out parameters get out, InOut get ref",
    "避免 C# 關鍵字衝突": "Avoid C# keyword conflicts",
    "生成 Rust FFI 綁定": "Generate Rust FFI bindings",
    "GenerateRustParameter(), TypeRef.ToRustType()": "GenerateRustParameter(), TypeRef.ToRustType()",
    "指標參數需要 unsafe 區塊": "Pointer parameters require unsafe block",
    "連結指令": "Link directive",
    "生成安全包裝器": "Generate safe wrappers",
    "生成單一 Rust extern 函數": "Generate single Rust extern function",
    "生成 extern \"C\" 函數聲明": "Generate extern \"C\" function declaration",
    "TypeRef.ToRustType()": "TypeRef.ToRustType()",
    "生成 Rust 安全包裝器": "Generate Rust safe wrapper",
    "將 unsafe extern 函數包裝為安全 Rust 函數": "Wrap unsafe extern function as safe Rust function",
    "所有 FFI 調用都是 unsafe": "All FFI calls are unsafe",
    "簡化的安全包裝器": "Simplified safe wrapper",
    "生成標準 C 頭檔格式": "Generate standard C header file format",
    "GenerateCFunction(), TypeRef.ToCType()": "GenerateCFunction(), TypeRef.ToCType()",
    "包含 include guard": "Includes include guard",
    "前向聲明": "Forward declarations",
    "函數聲明": "Function declarations",
    "生成單一 C 函數聲明": "Generate single C function declaration",
    "生成 C 函數原型": "Generate C function prototype",
    "TypeRef.ToCType()": "TypeRef.ToCType()",
    "空參數列表使用 void": "Empty parameter list uses void",
    "屬性註釋": "Attribute comment",
    "取得簽名中的所有結構類型名稱": "Get all struct type names from signature",
    "遞迴遍歷所有類型": "Recursively traverse all types",
    "自身遞迴": "Self-recursive",

    # InterfaceExtractor.cs
    "接口提取結果": "Interface extraction result",
    "封裝提取結果，包含成功/失敗狀態": "Encapsulates extraction result with success/failure status",
    "接口提取器 - 從編譯產物提取 FFI 接口": "Interface extractor - extracts FFI interface from compiled artifacts",
    "根據檔案類型選擇對應的提取策略": "Select extraction strategy based on file type",
    "ExtractFromCSharpAssembly(), ExtractFromNativeLibrary()": "ExtractFromCSharpAssembly(), ExtractFromNativeLibrary()",
    "不支援的檔案類型返回失敗": "Unsupported file type returns failure",
    "從編譯產物提取接口": "Extract interface from compiled artifacts",
    "根據副檔名選擇提取方法": "Select extraction method based on file extension",
    "檔案不存在返回失敗, 不支援的類型返回失敗": "File not found returns failure, unsupported type returns failure",
    "從 C# 程序集提取接口": "Extract interface from C# assembly",
    "使用 System.Reflection.Metadata 讀取方法簽名": "Read method signatures using System.Reflection.Metadata",
    "PEReader, MetadataReader": "PEReader, MetadataReader",
    "無公開方法返回空接口, 讀取失敗返回錯誤": "No public methods returns empty interface, read failure returns error",
    "只處理公開類型": "Process only public types",
    "只處理公開靜態方法": "Process only public static methods",
    "跳過特殊方法": "Skip special methods",
    "解析方法簽名": "Parse method signature",
    "解析 C# 方法": "Parse C# method",
    "從 MethodDefinition 讀取參數和返回類型": "Read parameters and return type from MethodDefinition",
    "MetadataReader.GetBlobReader()": "MetadataReader.GetBlobReader()",
    "複雜類型簡化為 void*": "Complex types simplified to void*",
    "簡化類型映射": "Simplified type mapping",
    "檢查 unsafe 屬性": "Check unsafe attribute",
    "無法解析的方法，返回簡化版本": "Unable to parse method, return simplified version",
    "映射 C# 類型到 FFI 類型": "Map C# type to FFI type",
    "根據類型代碼映射到原始類型": "Map to primitive type based on type code",
    "未知類型映射為 void*": "Unknown types mapped to void*",
    "從原生庫提取接口": "Extract interface from native library",
    "使用 nm 命令列出符號表": "List symbol table using nm command",
    "nm 不可用時返回空接口": "Returns empty interface when nm is unavailable",
    "使用 nm 列出符號": "List symbols using nm",
    "格式: address type name": "Format: address type name",
    "有時 nm 輸出沒有地址": "Sometimes nm output has no address",
    "T = text section (函數), D/B = data": "T = text section (function), D/B = data",
    "過濾 Rust mangled 符號": "Filter Rust mangled symbols",
    "移除前導下劃線": "Remove leading underscore",
    "跳過常見的系統符號": "Skip common system symbols",
    "建立基本函數描述": "Build basic function description",
    "預設返回 i32": "Default returns i32",
    "如果 nm 失敗，嘗試使用 objdump（Linux）": "If nm fails, try objdump (Linux)",
    "objdump 格式較複雜，提取 .text 區段的符號": "objdump format is more complex, extract symbols from .text section",
    "檢查是否為系統符號": "Check if it is a system symbol",
    "黑名單比對": "Blacklist matching",
    "類型提供者 - 用於解碼方法簽名": "Type provider - used for decoding method signatures",
    "複雜類型作為指標": "Complex types treated as pointers",

    # TypeSystem.cs
    "類型種類": "Type kind",
    "類型引用基類": "Type reference base class",
    "使用多態表示各種類型，支援 JSON 序列化": "Uses polymorphism to represent various types, supports JSON serialization",
    "Kind 決定子類型": "Kind determines subtype",
    "取得類型的 C 表示": "Get C representation of the type",
    "取得類型的 C# 表示": "Get C# representation of the type",
    "取得類型的 Rust 表示": "Get Rust representation of the type",
    "從 JSON 字串解析類型": "Parse type from JSON string",
    "根據 kind 欄位判斷類型並解析": "Determine and parse type based on kind field",
    "JsonDocument.Parse()": "JsonDocument.Parse()",
    "未知類型返回 null": "Unknown type returns null",
    "從 JsonElement 解析類型": "Parse type from JsonElement",
    "根據 kind 欄位建立對應類型實例": "Create corresponding type instance based on kind field",
    "JsonElement.GetProperty()": "JsonElement.GetProperty()",
    "未知 kind 返回 null, 缺少必填欄位返回 null": "Unknown kind returns null, missing required field returns null",
    "原始類型": "Primitive type",
    "使用單例模式表示基本類型": "Uses singleton pattern to represent basic types",
    "從字串解析原始類型": "Parse primitive type from string",
    "字串匹配": "String matching",
    "指標類型": "Pointer type",
    "封裝指標的目標類型、可空性、可變性": "Encapsulates pointer target type, nullability, and mutability",
    "Pointee.ToXxxType()": "Pointee.ToXxxType()",
    "陣列類型": "Array type",
    "封裝元素類型和可選的固定長度": "Encapsulates element type and optional fixed length",
    "Element.ToXxxType()": "Element.ToXxxType()",
    "Length 為 null 表示動態陣列": "Length being null indicates dynamic array",
    "固定陣列用指標": "Fixed arrays use pointers",
    "結構類型引用": "Struct type reference",
    "只儲存結構名稱，實際定義在別處": "Stores only the struct name, actual definition is elsewhere",
    "函數指標類型": "Function pointer type",
    "封裝函數簽名": "Encapsulates function signature",
    "Signature.ToXxxType()": "Signature.ToXxxType()",
    "函數參數": "Function parameter",
    "封裝參數名稱、類型、方向": "Encapsulates parameter name, type, and direction",
    "Direction 預設 In": "Direction defaults to In",
    "從 JsonElement 解析參數": "Parse parameter from JsonElement",
    "提取 name, type, direction 欄位": "Extract name, type, direction fields",
    "TypeRef.FromJsonElement()": "TypeRef.FromJsonElement()",
    "缺少必填欄位返回 null": "Missing required field returns null",
    "參數方向": "Parameter direction",
    "呼叫約定": "Calling convention",
    "函數簽名": "Function signature",
    "封裝參數列表、返回類型、呼叫約定": "Encapsulates parameter list, return type, and calling convention",
    "Convention 預設 Cdecl": "Convention defaults to Cdecl",
    "從 JsonElement 解析簽名": "Parse signature from JsonElement",
    "提取 params, return, convention 欄位": "Extract params, return, convention fields",
    "FunctionParameter.FromJsonElement(), TypeRef.FromJsonElement()": "FunctionParameter.FromJsonElement(), TypeRef.FromJsonElement()",
    "導出函數": "Exported function",
    "封裝函數名稱、簽名、屬性": "Encapsulates function name, signature, and attributes",
    "Attributes 可為空": "Attributes can be empty",
    "從 JsonElement 解析導出函數": "Parse exported function from JsonElement",
    "提取 name, signature, attributes 欄位": "Extract name, signature, attributes fields",
    "FunctionSignature.FromJsonElement()": "FunctionSignature.FromJsonElement()",
    "模組接口描述": "Module interface description",
    "完整的接口描述，包含模組資訊、導出、導入、類型定義": "Complete interface description including module info, exports, imports, and type definitions",
    "所有集合可為空但不為 null": "All collections can be empty but not null",
    "從 JSON 字串解析": "Parse from JSON string",
    "解析頂層欄位和 exports 陣列": "Parse top-level fields and exports array",
    "JsonDocument.Parse(), ExportedFunction.FromJsonElement()": "JsonDocument.Parse(), ExportedFunction.FromJsonElement()",
    "JSON 格式錯誤返回 null": "Malformed JSON returns null",
    "序列化為 JSON": "Serialize to JSON",
    "手動構建 JSON 結構": "Manually build JSON structure",
    "JsonSerializer.Serialize()": "JsonSerializer.Serialize()",

    # LinkConfig.cs
    "輸出類型": "Output type",
    "目標平台": "Target platform",
    "封裝平台和架構資訊": "Encapsulates platform and architecture information",
    "取得平台三元組": "Get platform triple",
    "根據 OS/Arch 生成標準三元組": "Generate standard triple from OS/Arch",
    "GetCurrentPlatform()": "GetCurrentPlatform()",
    "native 時使用當前平台": "Uses current platform when native",
    "取得當前平台": "Get current platform",
    "使用 OperatingSystem API": "Uses OperatingSystem API",
    "OperatingSystem.IsXxx()": "OperatingSystem.IsXxx()",
    "未知系統返回 unknown": "Unknown system returns unknown",
    "取得共享庫副檔名": "Get shared library extension",
    "根據 OS 返回對應副檔名": "Return corresponding extension based on OS",
    "未知系統返回 .so": "Unknown system returns .so",
    "取得可執行檔副檔名": "Get executable extension",
    "取得靜態庫副檔名": "Get static library extension",
    "鏈接配置": "Link configuration",
    "封裝鏈接器所需的所有配置": "Encapsulates all configuration required by the linker",
    "預設值適用於大多數情況": "Default values suitable for most cases",
    "輸出檔案名 (不含副檔名)": "Output filename (without extension)",
    "輸出目錄": "Output directory",
    "是否啟用 LTO": "Whether LTO is enabled",
    "是否剝離符號": "Whether to strip symbols",
    "額外的鏈接器標誌": "Additional linker flags",
    "系統庫": "System libraries",
    "庫搜索路徑": "Library search paths",
    "編譯配置 (debug/release)": "Build configuration (debug/release)",
    "詳細輸出": "Verbose output",
    "鏈接輸入 - 單一目標檔案或庫": "Link input - single object file or library",
    "封裝輸入檔案資訊": "Encapsulates input file information",
    "檔案路徑": "File path",
    "來源模組名稱": "Source module name",
    "來源語言": "Source language",
    "輸入類型": "Input type",
    "是否為膠水代碼": "Whether it is glue code",
    "鏈接輸入類型": "Link input type",
    "鏈接結果": "Link result",
    "封裝鏈接結果": "Encapsulates link result",

    # LinkerManager.cs
    "鏈接器管理器 - 選擇並執行平台鏈接器": "Linker manager - selects and executes platform linker",
    "維護可用鏈接器列表，根據目標平台選擇合適的鏈接器": "Maintains available linker list, selects appropriate linker based on target platform",
    "IPlatformLinker.LinkAsync()": "IPlatformLinker.LinkAsync()",
    "無可用鏈接器時返回錯誤": "Returns error when no linker is available",
    "建立鏈接器管理器並註冊預設鏈接器": "Create linker manager and register default linkers",
    "根據當前平台註冊對應的鏈接器": "Register corresponding linkers based on current platform",
    "Register()": "Register()",
    "根據平台註冊鏈接器（優先順序由上到下）": "Register linkers by platform (priority from top to bottom)",
    "註冊鏈接器": "Register linker",
    "將鏈接器加入列表": "Add linker to list",
    "設定偏好的鏈接器": "Set preferred linker",
    "根據名稱查找並設定偏好鏈接器": "Find and set preferred linker by name",
    "名稱不匹配時忽略": "Ignored when name doesn't match",
    "取得可用的鏈接器": "Get available linker",
    "遍歷所有鏈接器，檢查可用性": "Iterate all linkers, check availability",
    "IPlatformLinker.CheckAvailabilityAsync()": "IPlatformLinker.CheckAvailabilityAsync()",
    "無可用鏈接器返回 null": "Returns null when no linker is available",
    "優先使用偏好鏈接器": "Prefer the preferred linker",
    "遍歷所有鏈接器": "Iterate all linkers",
    "驗證所有鏈接器": "Validate all linkers",
    "並行檢查所有鏈接器可用性": "Check all linker availability in parallel",
    "執行鏈接": "Execute linking",
    "選擇合適的鏈接器並執行鏈接": "Select appropriate linker and execute linking",
    "GetAvailableLinkerAsync(), IPlatformLinker.LinkAsync()": "GetAvailableLinkerAsync(), IPlatformLinker.LinkAsync()",
    "無可用鏈接器返回錯誤, 輸入為空返回錯誤": "Returns error when no linker is available, returns error when inputs are empty",
    "分類輸入": "Classify inputs",
    "如果全是 CLR 程序集，不需要原生鏈接": "If all inputs are CLR assemblies, no native linking needed",
    "選擇鏈接器": "Select linker",
    "處理純 CLR 鏈接（實際上是複製）": "Handle pure CLR linking (actually copying)",
    "CLR 程序集不需要原生鏈接，直接複製到輸出目錄": "CLR assemblies don't need native linking, copy directly to output directory",
    "File.Copy()": "File.Copy()",
    "找出主程序集（可能是入口點）": "Find main assembly (possibly the entry point)",
    "複製主程序集": "Copy main assembly",
    "複製其他程序集": "Copy other assemblies",
    "複製 deps.json 和 runtimeconfig.json（如果存在）": "Copy deps.json and runtimeconfig.json (if they exist)",
    "收集編譯產物作為鏈接輸入": "Collect compilation artifacts as link inputs",
    "掃描編譯輸出目錄，收集可鏈接的檔案": "Scan build output directory, collect linkable files",
    "Directory.GetFiles()": "Directory.GetFiles()",
    "目錄不存在返回空列表": "Directory not found returns empty list",
    "根據語言確定要收集的檔案類型": "Determine file types to collect based on language",
    "判斷輸入類型": "Determine input type",
    "根據副檔名和語言判斷輸入類型": "Determine input type based on extension and language",

    # PlatformLinker.cs
    "平台鏈接器介面": "Platform linker interface",
    "抽象鏈接器操作，支援不同平台": "Abstracts linker operations, supports different platforms",
    "ProcessRunner": "ProcessRunner",
    "平台不支援時返回錯誤": "Returns error when platform is not supported",
    "取得鏈接器名稱": "Get linker name",
    "支援的平台": "Supported platforms",
    "檢查鏈接器是否可用": "Check if linker is available",
    "GNU ld 鏈接器": "GNU ld linker",
    "調用 ld 或 gcc 進行鏈接": "Invoke ld or gcc for linking",
    "ld 不可用時嘗試 gcc": "Try gcc when ld is unavailable",
    "檢查 ld 或 gcc 是否可用": "Check if ld or gcc is available",
    "嘗試 ld --version，失敗則嘗試 gcc": "Try ld --version, then try gcc on failure",
    "ProcessRunner.CommandExistsAsync()": "ProcessRunner.CommandExistsAsync()",
    "兩者都不可用返回失敗": "Returns failure when both are unavailable",
    "優先嘗試 ld": "Try ld first",
    "回退到 gcc -o (作為前端調用 ld)": "Fall back to gcc -o (as frontend calling ld)",
    "構建 ld/gcc 命令行參數並執行": "Build ld/gcc command line arguments and execute",
    "鏈接失敗返回錯誤訊息": "Returns error message on link failure",
    "過濾掉 CLR DLL (不能直接鏈接)": "Filter out CLR DLLs (cannot be linked directly)",
    "構建輸出路徑": "Build output path",
    "構建命令": "Build command",
    "GCC 模式": "GCC mode",
    "輸入檔案": "Input files",
    "庫路徑": "Library paths",
    "常用庫": "Common libraries",
    "純 ld 模式": "Pure ld mode",
    "動態鏈接器": "Dynamic linker",
    "額外標誌": "Extra flags",
    "LLVM lld 鏈接器": "LLVM lld linker",
    "調用 lld 或 clang 進行鏈接": "Invoke lld or clang for linking",
    "lld 不可用時嘗試 clang": "Try clang when lld is unavailable",
    "嘗試 lld": "Try lld",
    "回退到 clang": "Fall back to clang",
    "MSVC link.exe 鏈接器": "MSVC link.exe linker",
    "調用 MSVC link.exe": "Invoke MSVC link.exe",
    "僅支援 Windows": "Only supported on Windows",
    "標準庫": "Standard libraries",
    "Apple ld64 鏈接器": "Apple ld64 linker",
    "調用 macOS 的 ld 或 clang": "Invoke macOS ld or clang",
    "僅支援 macOS": "Only supported on macOS",
    "macOS 使用 clang 作為前端": "macOS uses clang as frontend",

    # IncrementalBuildManager.cs
    "模組快取條目": "Module cache entry",
    "記錄模組編譯狀態和檔案 hash": "Records module compilation status and file hash",
    "專案編譯快取": "Project build cache",
    "儲存所有模組的快取條目": "Stores cache entries for all modules",
    "增量編譯檢查結果": "Incremental build check result",
    "增量編譯管理器": "Incremental build manager",
    "比對檔案 hash 判斷是否需要重新編譯": "Compare file hashes to determine if recompilation is needed",
    "SHA256, File I/O": "SHA256, File I/O",
    "快取檔案不存在時視為全部需要重編": "Treat all modules as needing rebuild when cache file doesn't exist",
    "載入快取": "Load cache",
    "從 .forge-cache.json 讀取快取": "Read cache from .forge-cache.json",
    "檔案不存在返回空快取": "File not found returns empty cache",
    "儲存快取": "Save cache",
    "序列化快取到 .forge-cache.json": "Serialize cache to .forge-cache.json",
    "目錄不存在時建立": "Create directory if it doesn't exist",
    "檢查模組是否需要重新編譯": "Check if module needs recompilation",
    "比對源碼 hash、配置 hash、依賴 hash": "Compare source hash, config hash, and dependency hash",
    "ComputeSourceHash(), ComputeConfigHash()": "ComputeSourceHash(), ComputeConfigHash()",
    "任一 hash 不匹配或產物不存在則需要重編": "Rebuild needed if any hash doesn't match or artifact is missing",
    "計算當前 hash": "Compute current hash",
    "檢查快取": "Check cache",
    "比對 hash": "Compare hashes",
    "檢查產物是否存在": "Check if artifacts exist",
    "更新模組快取": "Update module cache",
    "記錄編譯後的 hash 和產物路徑": "Record post-compilation hashes and artifact paths",
    "清除快取": "Clear cache",
    "計算源碼 hash": "Compute source hash",
    "遍歷所有源檔案計算 SHA256": "Traverse all source files and compute SHA256",
    "SHA256.HashData()": "SHA256.HashData()",
    "空目錄返回空 hash": "Empty directory returns empty hash",
    "計算配置 hash": "Compute config hash",
    "讀取 module.json 並計算 SHA256": "Read module.json and compute SHA256",
    "計算依賴 hash": "Compute dependency hash",
    "將依賴列表排序後計算 SHA256": "Sort dependency list then compute SHA256",
    "空依賴返回固定 hash": "Empty dependencies returns fixed hash",

    # BuildOrchestrator.cs
    "編譯流程階段": "Build pipeline phase",
    "編譯進度回調": "Build progress callback",
    "編譯選項": "Build options",
    "封裝完整編譯流程的所有選項": "Encapsulates all options for the full build pipeline",
    "是否只編譯不鏈接": "Whether to compile only without linking",
    "是否生成膠水代碼": "Whether to generate glue code",
    "只編譯指定模組": "Compile only the specified module",
    "Dry run (只顯示計畫)": "Dry run (show plan only)",
    "增量編譯 (預設啟用)": "Incremental build (enabled by default)",
    "強制全量重建": "Force full rebuild",
    "進度回調": "Progress callback",
    "編譯結果": "Build result",
    "封裝完整編譯流程結果": "Encapsulates full build pipeline result",
    "單一模組編譯結果": "Single module build result",
    "編譯流程整合器 - 協調完整的編譯到鏈接流程": "Build pipeline orchestrator - coordinates full compile-to-link workflow",
    "整合 ConfigParser, DependencyAnalyzer, PluginHost, LinkerManager, IncrementalBuildManager": "Integrates ConfigParser, DependencyAnalyzer, PluginHost, LinkerManager, IncrementalBuildManager",
    "各子系統的方法": "Methods of each subsystem",
    "任一階段失敗則終止並返回錯誤": "Terminates and returns error if any phase fails",
    "執行完整編譯流程": "Execute full build pipeline",
    "依序執行: 配置解析 → 依賴分析 → 編譯 → 接口提取 → 膠水生成 → 鏈接": "Execute sequentially: config parsing -> dependency analysis -> compilation -> interface extraction -> glue generation -> linking",
    "ParseConfig(), AnalyzeDependencies(), CompileModules(), ExtractInterfaces(), GenerateGlue(), Link()": "ParseConfig(), AnalyzeDependencies(), CompileModules(), ExtractInterfaces(), GenerateGlue(), Link()",
    "任一階段失敗返回錯誤": "Returns error if any phase fails",
    "=== Phase 1: 配置解析 ===": "=== Phase 1: Configuration Parsing ===",
    "=== Phase 2: 依賴分析 ===": "=== Phase 2: Dependency Analysis ===",
    "計算編譯順序": "Compute compilation order",
    "轉換為模組名稱列表": "Convert to module name list",
    "過濾目標模組": "Filter target module",
    "找出目標模組及其依賴": "Find target module and its dependencies",
    "=== Phase 3: 編譯 ===": "=== Phase 3: Compilation ===",
    "增量編譯快取": "Incremental build cache",
    "追蹤已重建的模組（用於傳遞式失效）": "Track rebuilt modules (for transitive invalidation)",
    "同層級並行編譯": "Parallel compilation within same layer",
    "增量編譯檢查": "Incremental build check",
    "檢查依賴是否重建": "Check if dependencies were rebuilt",
    "更新快取": "Update cache",
    "檢查是否有失敗": "Check for failures",
    "儲存快取": "Save cache",
    "如果只編譯不鏈接": "If compile-only without linking",
    "=== Phase 4: 接口提取 ===": "=== Phase 4: Interface Extraction ===",
    "=== Phase 5: 膠水代碼生成 ===": "=== Phase 5: Glue Code Generation ===",
    "找出依賴此模組的其他模組": "Find other modules that depend on this module",
    "=== Phase 6: 鏈接 ===": "=== Phase 6: Linking ===",
    "格式化編譯計畫": "Format build plan",
    "取得模組的所有依賴（遞迴）": "Get all module dependencies (recursive)",

    # LanguagePluginFactory.cs
    "語言插件工廠 - 為所有 UEP v1.7C 收錄語言創建插件": "Language plugin factory - creates plugins for all UEP v1.7C registered languages",
    "從 LanguageDefinitions 創建 GenericLanguagePlugin 實例": "Creates GenericLanguagePlugin instances from LanguageDefinitions",
    "LanguageDefinitions.GetAllLanguages(), GenericLanguagePlugin ctor": "LanguageDefinitions.GetAllLanguages(), GenericLanguagePlugin ctor",
    "無語言定義時返回空列表": "Returns empty list when no language definitions exist",
    "取得所有語言插件 (70+ 種)": "Get all language plugins (70+ types)",
    "依語言 ID 取得插件": "Get plugin by language ID",
    "語言 ID (c, rust, python...)": "Language ID (c, rust, python...)",
    "語言插件，若不存在則返回 null": "Language plugin, returns null if not found",
    "依類別取得插件": "Get plugins by category",
    "語言類別": "Language category",
    "該類別的所有語言插件": "All language plugins of this category",
    "取得內建語言插件 (C, C#, Rust, Python)": "Get builtin language plugins (C, C#, Rust, Python)",
    "依檔案擴展名取得插件": "Get plugin by file extension",
    "檔案擴展名 (含 dot, 如 .rs)": "File extension (with dot, e.g. .rs)",
    "處理該擴展名的語言插件": "Language plugin that handles this extension",
    "取得插件統計": "Get plugin statistics",
    "確保初始化": "Ensure initialization",
    "重新載入所有插件 (用於熱更新)": "Reload all plugins (for hot reloading)",
    "擴展 GenericLanguagePlugin 以暴露 Definition": "Extend GenericLanguagePlugin to expose Definition",
    "取得語言定義": "Get language definition",
    "插件統計": "Plugin statistics",
    "總插件數": "Total plugin count",
    "內建插件數": "Builtin plugin count",
    "按類別統計": "Statistics by category",
    "所有語言 ID": "All language IDs",
    "格式化輸出": "Formatted output",
    "語言插件擴展方法": "Language plugin extension methods",
    "列印所有語言插件資訊": "Print all language plugin information",

    # GenericLanguagePlugin.cs
    "通用語言插件 - 基於 LanguageDefinition 動態支援所有語言": "Generic language plugin - dynamically supports all languages based on LanguageDefinition",
    "提供通用編譯框架，根據語言定義動態選擇工具鏈": "Provides generic compilation framework, dynamically selects toolchain based on language definition",
    "ProcessRunner, LanguageDefinitions": "ProcessRunner, LanguageDefinitions",
    "未安裝工具鏈返回失敗": "Returns failure when toolchain is not installed",
    "編譯模組": "Compile module",
    "根據語言定義選擇編譯命令並執行": "Select compilation command based on language definition and execute",
    "無可用工具鏈返回失敗": "Returns failure when no toolchain is available",
    "找到可用的工具鏈": "Find available toolchain",
    "收集源文件": "Collect source files",
    "準備輸出目錄": "Prepare output directory",
    "執行編譯": "Execute compilation",
    "收集產物": "Collect artifacts",
    "收集編譯產物": "Collect build artifacts",
    "如果沒有找到特定類型，嘗試收集所有非源文件": "If no specific types found, try collecting all non-source files",
    "生成 C 頭檔": "Generate C header file",
    "尋找可用的工具鏈": "Find available toolchain",
    "驗證工具鏈": "Validate toolchain",
    "工具鏈配置": "Toolchain configuration",
    "命令構建器介面": "Command builder interface",
    "通用 C 家族命令構建器": "Generic C-family command builder",
    "Cargo 命令構建器 (Rust)": "Cargo command builder (Rust)",
    "Go 命令構建器": "Go command builder",
    "dotnet 命令構建器": "dotnet command builder",
    "假設第一個是 .csproj/.fsproj": "Assume the first is .csproj/.fsproj",
    "工具鏈註冊表": "Toolchain registry",
    "系統編程語言": "System programming languages",
    "託管語言": "Managed languages",
    "腳本語言": "Scripting languages",
    "函數式語言": "Functional languages",
    "科學計算語言": "Scientific computing languages",
    "硬體描述語言": "Hardware description languages",
    "智能合約語言": "Smart contract languages",
    "為未明確配置的語言提供預設配置": "Provide default configuration for unconfigured languages",
    "各語言專用命令構建器": "Language-specific command builders",

    # PluginHost.cs
    "插件註冊結果": "Plugin registration result",
    "封裝插件載入/註冊結果": "Encapsulates plugin load/registration result",
    "插件主機 - 負責載入與管理語言插件": "Plugin host - loads and manages language plugins",
    "維護語言名稱到插件實例的映射，提供查詢與驗證功能": "Maintains language name to plugin instance mapping, provides query and validation functions",
    "ILanguagePlugin 實例": "ILanguagePlugin instances",
    "未註冊的語言返回 null, 重複註冊覆蓋舊插件": "Unregistered language returns null, duplicate registration overrides old plugin",
    "已註冊的語言列表": "Registered language list",
    "註冊內建插件": "Register builtin plugins",
    "建立並註冊所有內建語言插件": "Create and register all builtin language plugins",
    "RegisterPlugin(), CSharpPlugin, RustPlugin, CPlugin": "RegisterPlugin(), CSharpPlugin, RustPlugin, CPlugin",
    "任一插件註冊失敗記錄錯誤但繼續": "Record error but continue if any plugin registration fails",
    "系統語言": "System languages",
    "應用語言": "Application languages",
    "底層語言": "Low-level languages",
    "手動註冊插件 (供外部使用)": "Manually register plugin (for external use)",
    "註冊單一插件": "Register single plugin",
    "取得插件能力，以語言名稱為 key 存入字典": "Get plugin capabilities, store in dictionary with language name as key",
    "ILanguagePlugin.GetCapabilities()": "ILanguagePlugin.GetCapabilities()",
    "重複註冊覆蓋舊插件，null 插件返回失敗": "Duplicate registration overrides old plugin, null plugin returns failure",
    "取得指定語言的插件": "Get plugin for specified language",
    "Dictionary.TryGetValue()": "Dictionary.TryGetValue()",
    "未註冊返回 null": "Returns null when unregistered",
    "檢查語言是否已註冊": "Check if language is registered",
    "字典 ContainsKey": "Dictionary ContainsKey",
    "Dictionary.ContainsKey()": "Dictionary.ContainsKey()",
    "取得所有已註冊插件的能力": "Get capabilities of all registered plugins",
    "遍歷所有插件取得能力": "Iterate all plugins to get capabilities",
    "空字典返回空列表": "Empty dictionary returns empty list",
    "驗證所有插件的工具鏈": "Validate all plugin toolchains",
    "並行驗證所有插件工具鏈": "Validate all plugin toolchains in parallel",
    "ILanguagePlugin.ValidateToolchainAsync()": "ILanguagePlugin.ValidateToolchainAsync()",
    "返回所有驗證結果，包含失敗的": "Return all validation results, including failures",
    "根據檔案副檔名取得對應插件": "Get corresponding plugin by file extension",
    "遍歷所有插件，檢查支援的副檔名": "Iterate all plugins, check supported extensions",
    "PluginCapabilities.SupportedExtensions": "PluginCapabilities.SupportedExtensions",
    "無匹配返回 null": "Returns null when no match",

    # AsmPlugin.cs
    "Assembly 語言插件 - 支援 NASM/GAS/MASM/YASM": "Assembly language plugin - supports NASM/GAS/MASM/YASM",
    "調用彙編器編譯 .asm/.s 為目標檔": "Invoke assembler to compile .asm/.s to object files",
    "無彙編器時返回錯誤，不同平台使用不同彙編器": "Returns error when no assembler is found, different platforms use different assemblers",
    "優先檢查 NASM（跨平台，Intel 語法）": "Check NASM first (cross-platform, Intel syntax)",
    "檢查 YASM（NASM 相容）": "Check YASM (NASM compatible)",
    "檢查 GAS（GNU Assembler，通常透過 as 或 gcc）": "Check GAS (GNU Assembler, usually via as or gcc)",
    "Windows: 檢查 MASM (ml64)": "Windows: Check MASM (ml64)",
    "查找源碼": "Find source code",
    "決定目標格式": "Determine target format",
    "如果有明確指定格式": "If format is explicitly specified",
    "根據平台自動決定": "Automatically determine based on platform",
    "打包為靜態庫": "Package as static library",
    "Debug 符號": "Debug symbols",
    "DWARF 格式": "DWARF format",
    "Include 目錄": "Include directories",
    "預處理宏": "Preprocessor macros",
    "GNU Assembler": "GNU Assembler",
    "MASM": "MASM",
    "只編譯不鏈接": "Compile only, no linking",
    "使用 nm 提取全域符號": "Extract global symbols using nm",
    "macOS: -U 只顯示已定義": "macOS: -U shows only defined symbols",
    "T = text (code), D = data, B = bss": "T = text (code), D = data, B = bss",
    "過濾內部符號": "Filter internal symbols",
    "移除前導下劃線（macOS/Windows convention）": "Remove leading underscore (macOS/Windows convention)",
    "ASM 無法推斷類型": "ASM cannot infer types",

    # PluginLoader.cs
    "關鍵修復：使用顯式轉型穿透可能存在的 object 型別障礙": "Critical fix: use explicit cast to penetrate potential object type barriers",

    # Various plugins common patterns
    "C++ 語言插件 - 支援 clang++/g++/MSVC 編譯": "C++ language plugin - supports clang++/g++/MSVC compilation",
    "調用 C++ 編譯器編譯源碼，生成靜態庫": "Invoke C++ compiler to compile source code, generate static library",
    "無編譯器時返回錯誤，MSVC 使用不同參數格式": "Returns error when no compiler is found, MSVC uses different parameter format",
    "C 語言插件 - 支援 clang/gcc 編譯": "C language plugin - supports clang/gcc compilation",
    "調用 clang 或 gcc 編譯 C 源碼": "Invoke clang or gcc to compile C source code",
    "無編譯器時返回錯誤": "Returns error when no compiler is found",
    "優先嘗試 clang，失敗則嘗試 gcc": "Try clang first, then try gcc on failure",
    "優先嘗試 clang": "Try clang first",
    "回退到 gcc": "Fall back to gcc",
    "編譯 C 源碼": "Compile C source code",
    "收集 .c 檔案，調用 clang/gcc 編譯為 .o": "Collect .c files, invoke clang/gcc to compile to .o",
    "無源碼返回錯誤, 編譯失敗返回錯誤日誌": "Return error when no source code, return error logs on compilation failure",
    "確保工具鏈可用": "Ensure toolchain is available",
    "查找源碼目錄": "Find source directory",
    "建立輸出目錄": "Create output directory",
    "解析語言特定配置": "Parse language-specific configuration",
    "編譯每個源檔案": "Compile each source file",
    "建立靜態庫 (ar)": "Create static library (ar)",
    "建立編譯參數": "Build compilation arguments",
    "根據配置生成 clang/gcc 命令行參數": "Generate clang/gcc command line arguments based on configuration",
    "優化級別": "Optimization level",
    "Debug 資訊": "Debug information",
    "標準版本": "Standard version",
    "警告": "Warnings",
    "位置無關代碼 (用於共享庫)": "Position-independent code (for shared libraries)",
    "額外定義": "Extra defines",
    "額外包含路徑": "Extra include paths",
    "使用 nm 列出符號": "List symbols using nm",
    "nm 失敗返回空接口": "nm failure returns empty interface",
    "T = text section (函數)": "T = text section (function)",
    "過濾系統符號": "Filter system symbols",
    "生成目標語言的 FFI 綁定": "Generate FFI bindings for target language",
    "不支援的語言返回失敗": "Unsupported language returns failure",

    # GoPlugin.cs
    "Go 語言插件 - 支援 cgo 編譯為 C 共享庫": "Go language plugin - supports cgo compilation to C shared library",
    "調用 go build 生成 c-shared 庫，支援 cgo FFI": "Invoke go build to generate c-shared library, supports cgo FFI",
    "ProcessRunner.RunAsync(), go CLI": "ProcessRunner.RunAsync(), go CLI",
    "無 go 時返回錯誤，需啟用 CGO_ENABLED": "Returns error when go is unavailable, requires CGO_ENABLED",
    "查找 go.mod 或源碼": "Find go.mod or source code",
    "檢查 src 子目錄": "Check src subdirectory",
    "準備輸出": "Prepare output",
    "輸出檔案名稱": "Output filename",
    "構建參數": "Build arguments",
    "輸出路徑": "Output path",
    "編譯優化": "Compilation optimization",
    "設置環境變數": "Set environment variables",
    "c-shared 模式會生成 .h 頭文件": "c-shared mode generates .h header file",
    "支援格式: \"linux/amd64\", \"windows-x64\", \"darwin-arm64\"": "Supported formats: \"linux/amd64\", \"windows-x64\", \"darwin-arm64\"",
    "Go c-shared 會生成 .h 頭文件，從中提取接口": "Go c-shared generates .h header file, extract interface from it",
    "嘗試用 nm 提取": "Try extracting with nm",
    "解析 cgo 生成的 .h 文件": "Parse cgo-generated .h file",
    "格式: extern <type> <name>(<params>);": "Format: extern <type> <name>(<params>);",
    "跳過 Go 運行時內部符號": "Skip Go runtime internal symbols",
    "簡單解析": "Simple parsing",
    "過濾 Go 內部符號": "Filter Go internal symbols",
    "過濾 Go 運行時和 cgo 內部符號": "Filter Go runtime and cgo internal symbols",
    "Go 內部符號": "Go internal symbol",

    # PythonPlugin.cs
    "Python 語言插件 - 支援 Cython/mypyc 編譯為原生擴展": "Python language plugin - supports Cython/mypyc compilation to native extension",
    "調用 Cython/mypyc 編譯 Python 代碼為 .so/.pyd": "Invoke Cython/mypyc to compile Python code to .so/.pyd",
    "ProcessRunner.RunAsync(), cython/mypyc CLI": "ProcessRunner.RunAsync(), cython/mypyc CLI",
    "無 Python/Cython 時返回錯誤": "Returns error when Python/Cython is unavailable",
    "Python 交叉編譯較複雜": "Python cross-compilation is complex",
    "檢查 Python": "Check Python",
    "檢查 Cython": "Check Cython",
    "檢查 mypyc": "Check mypyc",
    "查找源文件": "Find source files",
    "Cython 編譯 .py/.pyx → .c": "Cython compile .py/.pyx to .c",
    "使用 C 編譯器編譯 .c → .so/.pyd": "Use C compiler to compile .c to .so/.pyd",
    "獲取 Python include 路徑": "Get Python include path",
    "編譯為共享庫": "Compile to shared library",
    "Python 庫連結": "Python library linking",
    "mypyc 在當前目錄生成 .so/.pyd": "mypyc generates .so/.pyd in current directory",
    "使用 nm 提取符號": "Extract symbols using nm",
    "過濾 Python/Cython 內部符號": "Filter Python/Cython internal symbols",
    "Python 函數通常返回 PyObject*": "Python functions typically return PyObject*",

    # TypeScriptPlugin.cs
    "TypeScript 語言插件 - 支援 tsc/esbuild/bun 編譯": "TypeScript language plugin - supports tsc/esbuild/bun compilation",
    "調用 TypeScript 工具鏈編譯為 JavaScript": "Invoke TypeScript toolchain to compile to JavaScript",
    "ProcessRunner.RunAsync(), tsc/esbuild/bun CLI": "ProcessRunner.RunAsync(), tsc/esbuild/bun CLI",
    "無工具鏈時返回錯誤": "Returns error when no toolchain is found",
    "TypeScript 編譯為 JS，非原生": "TypeScript compiles to JS, not native",
    "檢查 Node.js": "Check Node.js",
    "檢查打包工具": "Check bundler",
    "查找入口文件": "Find entry file",
    "查找任何 .ts 文件": "Find any .ts file",
    "生成類型宣告": "Generate type declarations",
    "檢查是否有 tsconfig.json": "Check for tsconfig.json",
    "收集產物": "Collect artifacts",
    "解析 .d.ts 文件提取類型定義": "Parse .d.ts file to extract type definitions",
    "嘗試從 JS 分析導出": "Try to analyze exports from JS",
    "簡單解析 export function / export const": "Simple parsing of export function / export const",
    "簡單解析 module.exports / exports.xxx": "Simple parsing of module.exports / exports.xxx",
    "找到生成的 .d.ts 文件": "Find generated .d.ts files",

    # Remaining misc patterns
    "CALLS: N/A": "CALLS: N/A",
    "EDGES: N/A": "EDGES: N/A",
    "APPROACH:": "APPROACH:",
    "CALLS:": "CALLS:",
    "EDGES:": "EDGES:",
}

def translate_file(filepath):
    """Translate Chinese comments in a single .cs file."""
    try:
        with open(filepath, 'r', encoding='utf-8-sig') as f:
            content = f.read()
    except:
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                content = f.read()
        except:
            return False, "Cannot read file"

    original = content

    # Apply all translations (longest first to avoid partial matches)
    sorted_keys = sorted(T.keys(), key=len, reverse=True)
    for zh, en in ((k, T[k]) for k in sorted_keys):
        content = content.replace(zh, en)

    if content != original:
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(content)
        return True, "Translated"
    else:
        return False, "No changes"

def main():
    # Find all .cs files (excluding obj/)
    cs_files = []
    for f in glob.glob(os.path.join(DIR, '*.cs')):
        if 'obj' not in f:
            cs_files.append(f)

    translated = 0
    skipped = 0
    errors = 0

    for filepath in sorted(cs_files):
        fname = os.path.basename(filepath)
        changed, msg = translate_file(filepath)
        if changed:
            translated += 1
            print(f"  [OK] {fname}")
        else:
            skipped += 1
            # print(f"  [--] {fname}: {msg}")

    print(f"\nDone: {translated} translated, {skipped} unchanged, {errors} errors")
    print(f"Total files processed: {len(cs_files)}")

if __name__ == '__main__':
    main()
